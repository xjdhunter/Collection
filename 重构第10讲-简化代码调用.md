## 10、简化函数调用
###### 概要
> 在讲解本章之前，我想和大家一起整理一下这章和前面几章的关系：
* 1.**重新组织函数**
> 在一个类中对类变量、方法进行操作，如函数的合并与分解，临时变量的提取与分解，以查询函数取代复用的临时变量等手法实现重新组织函数。
* 2.**在对象间搬移特性**
> 在多个类之间对类、类的特性进行操作，如根据特性与类的亲疏关系搬移函数和字段，对类进行合并与分解等手法实现在对象之间搬移特性进行重构。
* 3.**简化函数调用**
> 本章则是在一个更小的范围内进行，针对的是函数的本身（即构成一个函数的基本要素函数名、参数）做重构。
#### 10.1、Rename Method(函数改名)
* 场景
> 随着迭代开发的不断进行，一个函数所具备的功能可能已经远远大于了最初创建者的赋予本意，这时候我们想到了什么？
  ？？？？？？
```
people getPeoplesConfig(int id) {
        People people = dao.getPeoplesConfig(id);

        if (people.getAge() > 0 && people.getAge() <= 18) {
            if (people.getSex == 1) {
                System.out.print("他叫" + people.getName() + ",是一名男性少年");
            }
            System.out.print("她叫" + people.getName() + ",是一名女性少年");
        }

        if (people.getAge() > 18 && people.getAge() <= 44) {
            if (people.getSex() == 1) {
                System.out.print("他叫" + people.getName() + ",是一名男性青年");
            }
            System.out.print("她叫" + people.getName() + ",是一名女性青年");
        }

        if (people.getAge() > 44 && people.getAge() <= 60) {
            if (people.getSex == 1) {
                System.out.print("他叫" + people.getName() + ",是一名男性中年");
            }
            System.out.print("她叫" + people.getName() + ",是一名女性中年");
        }

        if (people.getAddress().equals("西安")) {
            System.out.print("是一名西安人");
        } else {
            System.out.print("不是一名西安人");
        }
    }
 ```
*  函数内部功能过于复杂，使用 Extract Method() 进行函数提炼
```
 people getPeopleConfig(int id) {
        People people = dao.getPeopleConfig(id);

        getSexAndAgetAndName(prople);
        getAddress(people);
       
    }

    getSexAndAge(People people) {
        if (people.getAge() > 0 && people.getAge() <= 18) {
            if (people.getSex() == 1) {
                System.out.print("他叫" + people.getName() + ",是一名男性少年");
            }
            System.out.print("她叫" + people.getName() + ",是一名女性少年");
        }

        if (people.getAge() > 18 && people.getAge() <= 44) {
            if (people.getSex() == 1) {
                System.out.print("他叫" + people.getName() + ",是一名男性青年");
            }
            System.out.print("她叫" + people.getName() + ",是一名女性青年");
        }

        if (people.getAge() > 44 && people.getAge() <= 60) {
            if (people.getSex() == 1) {
                System.out.print("他叫" + people.getName() + ",是一名男性中年");
            }
            System.out.print("她叫" + people.getName() + ",是一名女性中年");
        }
    }

    getAddress(people) {
        if (people.getAddress().equals("西安")) {
            System.out.print("是一名西安人");
        } else {
            System.out.print("不是一名西安人");
        }
    }
 ```
* 思考进行提炼后的各函数是否存在问题？
> 函数命名不合理，函数名没有准确的表达出函数本身的功能，这样会对函数的调用者造成误导；函数提炼不彻底，任然存在重复代码，可对重复代码继续提炼。

```
  String getPeopleConfigById(int id) {
        People people = dao.getPeopleConfig(id);

        return "他叫："+people.getName()+",是一个"+getSex(people.getSex())+determineAgeStage(people.getAge())+isXianPeople(people.getAddress());

    }

    String determineAgeStage(int age) {
        if (people.getAge() > 0 && people.getAge() <= 18) {
           return "少年";
        }

        if (people.getAge() > 18 && people.getAge() <= 44) {
            return "青年";
        }

        if (people.getAge() > 44 && people.getAge() <= 60) {
            return "中年";
        }
    }

    String getSex (int sex) {
        if (people.getSex() == 1) {
            return "男";
        }
        return "女";
    }

    String isXianPeople(String address) {
        if (people.getAddress().equals("西安")) {
           return "是西安人";
        }
        return "不是西安人";
    }
   ```

#### 10.2、Add/Remove Parameter (添加与去除参数)
> 看到一个函数，怎么去判别是否需要使用本重构手法。首先我们先看看参数，然后进行下面几个流程
* Add Parameter
> 按序执行，优先级递减
1. 你能从这些参数得到所需的信息吗？ 
2. 缺失的信息可以通过某个函数进行获取吗？ 
3. 你究竟把这些信息都用来干嘛了，每一个信息都是必要的吗？
4. 这个函数是否应该属于拥有该参数的那个对象？ 
5. 考虑 Move Method()。
6. 考虑加入新参数是否合适？
7. 考虑 Introduce Parameter Object()。
8. 添加新参数
9. 退出
* Remove Parameter
1. 所有的参数是否都有他的用途？ 否 goto 5
2. 部分参数是否可以通过函数进行获取？ 是 goto 5
3. 函数是否应该属于参数所属的类？ 是 goto 4
4. 考虑Move Method
5. 去除参数

#### 10.3、Separate Query from Modifier (将查询函数和修改函数分离)
> 函数的两个重要类型
1. 查询函数-->根据一些线索进行数据获取
2. 修改函数-->把数据进行一些特别的处理已达到某些目的
> 很多时候我们都把这两个函数揉在一起进行使用，查询函数里面有修改，修改函数里面有查询。从而导致其他想要获取原始数据的人调用这种函数得到的是加工后的数据，想要进行数据修改的函数调用者又得到了一大堆自己不想要的多余数据。

> 如果我们一直遵循把查询函数和修改函数分离的原则，查询函数只负责数据获取，修改函数只执行特定的数据处理，这样会极大的增强代码的可读性和降低修改成本。

#### 10.4、 Parameterize Method(令函数携带参数)
> 当你发现某几个函数，他们做着类似的工作，但因少数几个值导致了行为的略有不同。
```
Dollars baseCharge() {
        double result = Math.min(lastUsage(), 100) * 0.03; //Math.min(x, y)获取两者中小的一个
        if(lastUsage > 100) {
            result += (Math.min(lastUsage(), 200) - 100) * 0.05;
        }

        if(lastUsage > 200) {
            result += (lastUsage() - 200) * 0.07;
        }
        
        return new Dollars(result);
    }
```
---
```
    Dollars baseCharge() {
        double result = Math.min(lastUsage(), 100) * 0.03; //Math.min(x, y)获取两者中小的一个
        result += usageInRange(100, 200) * 0.05;
        result += usageInRange(200, Integer.MAX_VALUE) * 0.07;
        return new Dollars(result);
    }

    int usageInRange(int start, int end) {
        if(lastUsage > start) {
            return Math.min(lastUsage(), end) - start;
        }else {
            return 0;
        }
    }
 ```
#### 10.5、 Replace Parameter with Explicit Methods (以明确函数取代参数)
